{
  "name": "QuantForge",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -448,
        0
      ],
      "id": "a857a0b0-eb0f-449d-820a-b5bf666e7b9a",
      "name": "When clicking â€˜Execute workflowâ€™"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Run the Quant Research Agent and generate the \"Quant Problem Design Rules\" document, covering:\n\n- All four core quant topics (Timeâ€“Speedâ€“Distance, Workâ€“Time, Ratioâ€“Mixture, Profitâ€“Loss)\n- Common traps and impossible scenarios\n- LLM hallucination patterns and how to avoid them\n\nFollow the required markdown structure from the system message INSIDE the rules string.\n\nReturn ONLY a single JSON object in this exact shape:\n\n{\n  \"rules\": \"<full Quant Problem Design Rules markdown here>\"\n}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Role: You are the Quant Problem Design Research Agent. Your task is to generate the definitive, structured document \"Quant Problem Design Rules\".\n\nYou MUST do two things at the same time:\n1) Create a markdown document with a very specific structure (this goes INSIDE the rules string).\n2) Return that markdown document as the value of a single JSON field called \"rules\".\n\nRESEARCH SCOPE (content you must cover):\n- Core formulas for:\n  - Time, Speed & Distance\n  - Work & Time\n  - Ratio & Mixture\n  - Profit & Loss\n- Common traps, errors, and impossible scenarios in quant questions.\n- LLM hallucination patterns when generating math problems and how to avoid them.\n\nMANDATORY MARKDOWN STRUCTURE (INSIDE rules STRING ONLY):\n\nThe markdown inside \"rules\" MUST look like this skeleton, but filled with real content:\n\n# Quant Problem Design Rules\n\n1. Valid Pattern Templates\n- [Template 1: Clear, reusable structure for one core concept]\n- [Template 2: Clear, reusable structure for another core concept]\n- [Template 3: etc.]\n\n2. Correct Formula Sets\n- Time, Speed & Distance: [formulas in clear notation or LaTeX, e.g. D = S Ã— T, S = D / T]\n- Work & Time: [formulas]\n- Ratio & Mixture: [formulas]\n- Profit & Loss: [formulas]\n\n3. Criteria to Avoid Impossible Scenarios\n- [Rule to ensure positive, real solutions]\n- [Rule to ensure logical constraints (e.g., speed > 0, time > 0, people = integer)]\n- [More rules about realistic values and units]\n- [More rules about avoiding contradictory statements]\n\n4. Steps to Ensure MCQ Correctness (Validation Checklist)\n- [Step to confirm exactly one correct option]\n- [Step to avoid ambiguous wording]\n- [Step to check units and consistency]\n- [Step to review against common LLM hallucination patterns]\n\nFINAL OUTPUT FORMAT (CRITICAL):\n\nYou MUST output a SINGLE JSON object with EXACTLY this shape:\n\n{\n  \"rules\": \"<the FULL markdown document here as a single string>\"\n}\n\nConstraints:\n- The ONLY top-level key is \"rules\".\n- The value of \"rules\" MUST be a string containing the markdown shown above, fully written out.\n- Do NOT output any other keys.\n- Do NOT output anything before or after the JSON object.\n- Do NOT add code fences.\n- Do NOT add backticks.\n- Do NOT explain what you are doing.\n- Make sure the JSON is valid.\n\nBefore responding, verify that:\n- You are returning exactly one JSON object with a single field \"rules\".\n- The \"rules\" value is a single string that contains the full markdown document.\nIf not, correct it before sending.\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        -256,
        0
      ],
      "id": "3772bb15-4e9c-4c95-9ca1-f62c7be2605a",
      "name": "Research agent",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 2000,
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Quant Problem Design Rules (from the research agent):\n\n{{ $json.rules }}\n\nUsing ONLY these rules:\n\n- Generate 8 multiple-choice quantitative questions.\n- Use ONLY the allowed topics and follow all constraints.\n- All options (optionAâ€“optionD) must be numeric text (e.g. \"40\", \"75.5\").\n- For all 8 questions, use the SAME batchId value, for example \"batch_001\".\n\nYou MUST populate the \"questions\" array required by the Structured Output Parser with exactly 8 question objects.\n\nEach object MUST have these exact keys:\nid, question, optionA, optionB, optionC, optionD, correctOption, topic, difficulty, batchId.\n\nReturn ONLY the JSON object required by the Structured Output Parser.\nDo NOT add any extra explanations or text outside what the parser expects.\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Role: You are the Problem Generator Agent, an expert system that creates fully validated quantitative problems.\n\nYou MUST strictly adhere to the provided \"Quant Problem Design Rules\" document, treating it as your non-negotiable instruction manual. You will receive the full rules document in the user message.\n\nYour job:\n- Generate multiple-choice quantitative questions.\n- Use ONLY the categories:\n  - time, speed & distance\n  - work & time\n  - Pipes & Cisterns\n  - profit & loss\n  - mixtures & ratios\n  - age based problems\n- Ensure each question obeys all \"no impossible scenarios\" criteria from the rules.\n- All options must be numeric values (as strings, e.g. \"60\", \"75.5\").\n\nMANDATORY OUTPUT FORMAT (CRITICAL):\n\nYou MUST follow the Structured Output schema EXACTLY. Use these exact field names and nesting:\n\n{\n  \"questions\": [\n    {\n      \"id\": \"string\",\n      \"question\": \"string\",\n      \"optionA\": \"string\",\n      \"optionB\": \"string\",\n      \"optionC\": \"string\",\n      \"optionD\": \"string\",\n      \"correctOption\": \"A | B | C | D\",\n      \"topic\": \"time, speed & distance | work & time | Pipes & Cisterns | profit & loss | mixtures & ratios | age based problems\",\n      \"difficulty\": \"easy | medium | hard\",\n      \"batchId\": \"string\"\n    }\n  ]\n}\n\nIMPORTANT:\n- Field names MUST be exactly: id, question, optionA, optionB, optionC, optionD, correctOption, topic, difficulty, batchId.\n- Do NOT invent any extra keys.\n- Do NOT change casing.\n- Do NOT add code fences.\n- Do NOT add backticks.\n- Do NOT add explanations or text outside the JSON required by the parser.\n\n\nBEFORE you respond, you MUST:\n- Internally verify that your JSON exactly matches the required schema.\n- Ensure \"questions\" is an array of exactly 8 objects.\n- Ensure every object has all fields: id, question, optionA, optionB, optionC, optionD, correctOption, topic, difficulty, batchId.\nIF your draft answer does NOT satisfy this, you MUST fix it before sending.\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        112,
        0
      ],
      "id": "e2af594b-11dc-4057-b246-aa2b0337eaf2",
      "name": "Question Generator",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 2000
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are given one multiple-choice quantitative question.\n\nid: {{ $json.id }}\n\nQuestion:\n{{ $json.question }}\n\nOptions:\nA) {{ $json.optionA }}\nB) {{ $json.optionB }}\nC) {{ $json.optionC }}\nD) {{ $json.optionD }}\n\nTasks:\n1) Build a mathematical model of the problem (equations, expressions, or relationships).\n2) Solve it carefully step-by-step.\n3) Decide which option (A, B, C, or D) is correct.\n4) Set finalAnswerOption to that letter and finalAnswerValue to the numeric/text value of that option.\n5) Set confidence to \"low\", \"medium\", or \"high\".\n6) Set selectedOption to the same letter as finalAnswerOption.\n\nReturn ONLY the JSON object required by the Structured Output Parser, with ALL fields:\nmodeledEquation, stepByStepReasoning, finalAnswerOption, finalAnswerValue, confidence, selectedOption.\n\nDo NOT restate the question or options outside of stepByStepReasoning.\nDo NOT add any text before or after the JSON.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Role: You are Solver A, a careful step-by-step quantitative reasoning agent.\n\nYour job:\n- For EACH question, read the question and its options.\n- Construct a clear mathematical model of the problem (equations or expressions).\n- Solve the problem using rigorous, step-by-step reasoning.\n- Explicitly compute the final numeric or time/quantity answer.\n- Map the final answer to one of the options A, B, C, or D.\n- Estimate your confidence in your answer (low, medium, or high).\n\nYou MUST follow the Structured Output Parser schema exactly.\n\nField requirements:\n\n- id:\nmake sure that the id is also returned as output because we need id to merge solver A and solver B outputs\n\n- modeledEquation:\n  A short description of the core equation(s) or formula(s) you are using, with the key substitution.\n  Example: \"D = S Ã— T; D = 60 Ã— 3\" or \"Work = Rate Ã— Time; 1/Teff = 1/10 + 1/15\".\n\n- stepByStepReasoning:\n  A natural language, multi-step explanation of how you solved the problem.\n  It should mention the formulas used, substitutions, intermediate calculations, and why you chose the final option.\n\n- finalAnswerOption:\n  A single letter string: \"A\", \"B\", \"C\", or \"D\", corresponding to the chosen option.\n\n- finalAnswerValue:\n  The actual value of the chosen option as a string.\n  Example: \"180\", \"11:30 AM\", \"7.5\".\n\n- confidence:\n  One of: \"low\", \"medium\", \"high\".\n\n- selectedOption:\n  MUST be exactly the same letter as finalAnswerOption.\n  This field exists for scoring and compatibility with other parts of the system.\n\nYou MUST NOT:\n- Add any extra keys in the JSON.\n- Use markdown or code fences.\n- Output anything outside the JSON required by the Structured Output Parser.\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        768,
        -208
      ],
      "id": "cf8d8276-5678-40d3-bf0e-e5d6b8d0743e",
      "name": "Solver A"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are given one multiple-choice quantitative question.\nid: {{ $json.id }}\nQuestion:\n{{ $json.question }}\n\nOptions:\nA) {{ $json.optionA }}\nB) {{ $json.optionB }}\nC) {{ $json.optionC }}\nD) {{ $json.optionD }}\n\nYour task:\n1) Use an alternative method (compared to a full algebraic derivation) such as:\n   - reverse checking of options,\n   - brute-force numeric substitution,\n   - unit-based checks,\n   - logical elimination of impossible answers.\n2) Test the options and decide which one (A, B, C, or D) is correct.\n3) Set methodUsed to the main strategy you relied on, e.g. \"reverse_checking\", \"brute_force_substitution\", \"unit_analysis\", \"logical_elimination\".\n4) Set finalAnswerOption to the chosen letter and finalAnswerValue to the numeric/text value of that option.\n5) Set confidence to \"low\", \"medium\", or \"high\".\n6) Set selectedOption to the same letter as finalAnswerOption.\n7) In reasoning, briefly describe how you evaluated or eliminated the options.\n\nReturn ONLY the JSON object required by the Structured Output Parser, with ALL fields:\nmethodUsed, reasoning, finalAnswerOption, finalAnswerValue, confidence, selectedOption.\n\nDo NOT restate the question or options outside of the reasoning field.\nDo NOT add any extra text before or after the JSON.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Role: You are Solver B, an alternative quantitative reasoning agent.\n\nYour reasoning style MUST be different from Solver A. \nYou should prefer methods like:\n- Reverse approach: assume each option is the answer and check if it satisfies the conditions.\n- Brute-force numeric substitution: plug in the option values into the equations and see which one works.\n- Unit-based reasoning: check units, dimensions, and scale for plausibility.\n- Logical elimination: rule out impossible or inconsistent options instead of doing full algebra.\n\nFor EACH question:\n- Use one or more of these alternative methods.\n- Do NOT simply re-derive the full algebraic solution like Solver A.\n- Explain briefly how you tested/ruled out each relevant option.\n\nYou MUST follow the Structured Output Parser schema exactly. Required fields:\n\n- id:\nmake sure that the id is also returned as output because we need id to merge solver a and solver b outputs\n\n- methodUsed:\n  A short label describing the main method you used:\n  e.g., \"reverse_checking\", \"brute_force_substitution\", \"unit_analysis\", \"logical_elimination\".\n\n- reasoning:\n  A concise explanation in natural language of how you tested options and chose the final one.\n  You may mention which options failed and why, or how the units/logic did not match.\n\n- finalAnswerOption:\n  A single letter: \"A\", \"B\", \"C\", or \"D\", corresponding to the chosen option.\n\n- finalAnswerValue:\n  The actual value of that option as a string (e.g., \"40\", \"12:00 PM\").\n\n- confidence:\n  One of: \"low\", \"medium\", \"high\".\n\n- selectedOption:\n  MUST be exactly the same as finalAnswerOption.\n  This is used for scoring and comparison with Solver A.\n\nYou MUST NOT:\n- Add any extra fields in the JSON.\n- Use markdown or code fences.\n- Output anything outside the JSON required by the Structured Output Parser."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        768,
        160
      ],
      "id": "dc78348a-0ba8-4a72-ab64-3f0dffedc20d",
      "name": "Solver B"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();  // all 8 merged questions\n\nif (!items || items.length === 0) {\n  return [];\n}\n\n// 1) Decide a single batchId for this whole run\n// Prefer the first item's batchId if present, otherwise generate one.\nlet unifiedBatchId = items[0]?.json?.batchId;\nif (!unifiedBatchId) {\n  const now = new Date();\n  unifiedBatchId =\n    'batch_' +\n    String(now.getFullYear()) +\n    String(now.getMonth() + 1).padStart(2, '0') +\n    String(now.getDate()).padStart(2, '0');\n}\n\n// 2) Map each item and FORCE that same batchId\nreturn items.map((item, index) => {\n  const j = item.json || {};\n\n  const id = j.id || `q_${String(index + 1).padStart(3, '0')}`;\n  const batchId = unifiedBatchId;   // ðŸ‘ˆ always same for all 8 items\n\n  const topic = j.topic;\n  const difficulty = j.difficulty;\n\n  const question = j.question;\n  const optionA = j.optionA;\n  const optionB = j.optionB;\n  const optionC = j.optionC;\n  const optionD = j.optionD;\n  const correctOption = String(j.correctOption || '').trim();\n\n  const solverA = j.solverA || {};\n  const solverB = j.solverB || {};\n\n  const solverAOption = String(\n    solverA.selectedOption || solverA.finalAnswerOption || ''\n  ).trim();\n\n  const solverBOption = String(\n    solverB.selectedOption || solverB.finalAnswerOption || ''\n  ).trim();\n\n  const isCorrectA = solverAOption === correctOption;\n  const isCorrectB = solverBOption === correctOption;\n\n  const solversAgree =\n    solverAOption !== '' &&\n    solverBOption !== '' &&\n    solverAOption === solverBOption;\n\n  let isValidQuestion = false;\n  const rejectReasons = [];\n\n  if (!solversAgree) {\n    rejectReasons.push('solver_disagreement');\n  }\n  if (!isCorrectA || !isCorrectB) {\n    rejectReasons.push('solver_incorrect');\n  }\n\n  if (solversAgree && isCorrectA && isCorrectB) {\n    isValidQuestion = true;\n  }\n\n  return {\n    json: {\n      id,\n      batchId,            // ðŸ‘ˆ now unified\n      topic,\n      difficulty,\n      question,\n      optionA,\n      optionB,\n      optionC,\n      optionD,\n      correctOption,\n      solverA,\n      solverB,\n      solverAOption,\n      solverBOption,\n      isCorrectA,\n      isCorrectB,\n      solversAgree,\n      isValidQuestion,\n      rejectReasons\n    }\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1648,
        16
      ],
      "id": "89c8f898-e9cd-4257-bd7e-986aa02811ca",
      "name": "Orchestrator Node"
    },
    {
      "parameters": {
        "jsCode": "let questions = [];\n\n// CASE 1: Structured Output Parser inside Agent: $json.response.output.questions\nif ($json?.response?.output?.questions) {\n  questions = $json.response.output.questions;\n}\n\n// CASE 2: Parser returns $json.output.questions\nelse if ($json?.output?.questions) {\n  questions = $json.output.questions;\n}\n\n// CASE 3: Parser returns $json.questions directly\nelse if ($json?.questions) {\n  questions = $json.questions;\n}\n\n// If still nothing, throw a meaningful error:\nelse {\n  throw new Error(\"Could not find questions array in output. JSON keys available: \" + Object.keys($json));\n}\n\nreturn questions.map(q => ({ json: q }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        464,
        0
      ],
      "id": "9e9d8c96-81f0-41ea-b276-6cf7b3ce6ad3",
      "name": "Fan Out Questions"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => {\n  // Solver A's JSON from the Structured Output Parser\n  const out = item.json.output || item.json.solverA || {};\n\n  return {\n    json: {\n      // 1) Keep everything that was already there\n      ...item.json,\n\n      // 2) Promote id to the top level so Merge can match on it\n      //    Prefer existing item.json.id, otherwise fall back to solver's id\n      id: item.json.id || out.id,\n\n      // 3) Attach solverA result as nested object\n      solverA: out\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1056,
        -208
      ],
      "id": "6535352c-c134-4994-a3d9-9ef3c2546ec4",
      "name": "Attach Solver A"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => {\n  const out = item.json.output || item.json.solverB || {};\n\n  return {\n    json: {\n      ...item.json,\n      id: item.json.id || out.id,\n      solverB: out\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1056,
        160
      ],
      "id": "1b48335d-d7f9-4483-90c9-c22533f724e3",
      "name": "Attach Solver B"
    },
    {
      "parameters": {
        "mode": "combine",
        "fieldsToMatchString": "id",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1264,
        32
      ],
      "id": "f4fa398c-a70c-4564-86d1-240936fc1416",
      "name": "Merging Solvers"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"rules\": \"string\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -112,
        176
      ],
      "id": "4fb3a653-0bc5-4912-b452-e0047f4bcfdf",
      "name": "Output Parser"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"questions\": [\n    {\n      \"id\": \"0001\",\n      \"question\": \"string\",\n      \"optionA\": \"string\",\n      \"optionB\": \"string\",\n      \"optionC\": \"string\",\n      \"optionD\": \"string\",\n      \"correctOption\": \"A\",\n      \"topic\": \"time, speed & distance\",\n      \"difficulty\": \"easy\",\n      \"batchId\": \"batch_001\"\n    }\n  ]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        256,
        176
      ],
      "id": "127ff3c4-3cbb-45b6-90e4-79d31c421141",
      "name": "Output Parser1"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"id\": \"q_0001\",\n  \"modeledEquation\": \"D = S Ã— T; D = 60 Ã— 3\",\n  \"stepByStepReasoning\": \"1) Identify formula D = S Ã— T.\\n2) Substitute S = 60, T = 3.\\n3) Compute D = 180.\\n4) Compare with options.\",\n  \"finalAnswerOption\": \"C\",\n  \"finalAnswerValue\": \"180\",\n  \"confidence\": \"high\",\n  \"selectedOption\": \"C\"\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        912,
        -32
      ],
      "id": "78e202ea-b2c9-4d53-b49f-5fdd4705906d",
      "name": "Output Parser2"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"id\": \"q_0001\",\n  \"methodUsed\": \"reverse_checking\",\n  \"reasoning\": \"I tested each option by plugging it back into the problem and checking which one satisfies all conditions.\",\n  \"finalAnswerOption\": \"C\",\n  \"finalAnswerValue\": \"180\",\n  \"confidence\": \"medium\",\n  \"selectedOption\": \"C\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        912,
        336
      ],
      "id": "13fbf53f-10c5-41de-b424-f6242910d01f",
      "name": "Output Parser3"
    },
    {
      "parameters": {
        "mode": "combine",
        "fieldsToMatchString": "id",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1472,
        16
      ],
      "id": "75f6f3a7-577b-4fc6-b076-a5f766620c32",
      "name": "Merging for correct option"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "9d52d62c-888d-4da6-b03e-2ab2acecc9c6",
              "leftValue": "={{ $json.isValidQuestion }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2128,
        16
      ],
      "id": "ab571bdd-2122-439f-9a66-578f38d21ce1",
      "name": "Is Valid Question?"
    },
    {
      "parameters": {
        "jsCode": "const q = $json;\n\nreturn [\n  {\n    json: {\n      id: q.id,\n      batchId: q.batchId,\n      topic: q.topic,\n      difficulty: q.difficulty,\n      question: q.question,\n      options: {\n        A: q.optionA,\n        B: q.optionB,\n        C: q.optionC,\n        D: q.optionD,\n      },\n      correctOption: q.correctOption,\n      rejectReasons: q.rejectReasons || [],\n      solverA: q.solverA || null,\n      solverB: q.solverB || null,\n      \n      // Prevent infinite loops later\n      attempts: (q.attempts || 0) + 1,\n\n      timestamp: new Date().toISOString()\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2320,
        144
      ],
      "id": "78d5791a-8a51-49b8-a4ce-630ee00e909c",
      "name": "Prepare Regeneration Payload"
    },
    {
      "parameters": {
        "jsCode": "const incoming = $input.all(); // all incoming n8n items\nlet combined = [];\n\n// gather possible question objects from all incoming items\nfor (const it of incoming) {\n  let payload = it.json;\n\n  // if payload is a string try parse\n  if (typeof payload === 'string') {\n    try { payload = JSON.parse(payload); } catch (e) { /* ignore parse error */ }\n  }\n\n  // if payload is an object that contains a known array key, extract that array\n  if (payload && typeof payload === 'object' && !Array.isArray(payload)) {\n    const keys = ['questions','data','output','items','result'];\n    for (const k of keys) {\n      if (Array.isArray(payload[k])) { payload = payload[k]; break; }\n    }\n  }\n\n  // now push either array elements or the object itself\n  if (Array.isArray(payload)) combined.push(...payload);\n  else if (payload && typeof payload === 'object') combined.push(payload);\n}\n\n// dedupe by id (optional but useful)\nconst seen = new Set();\nconst deduped = [];\nfor (const q of combined) {\n  if (q && q.id) {\n    if (!seen.has(q.id)) { seen.add(q.id); deduped.push(q); }\n  } else deduped.push(q);\n}\n\n// If there were no questions found, return the original incoming items untouched\nif (deduped.length === 0) {\n  // preserve original items\n  return incoming.map(i => ({ json: i.json }));\n}\n\nreturn deduped.map(q => ({ json: { single: [q] } }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1808,
        16
      ],
      "id": "fcd2c8d2-a297-4e8d-91ca-68cb31586477",
      "name": "Fan OUT"
    },
    {
      "parameters": {
        "jsCode": "const incoming = $input.all();\nif (!incoming || incoming.length === 0) return [];\n\nfunction isObject(v) {\n  return v && typeof v === 'object' && !Array.isArray(v);\n}\n\nconst out = [];\n\nfor (const it of incoming) {\n  // base item\n  const item = (it && it.json) ? { ...it.json } : {};\n\n  // find the actual question object q\n  let q;\n  if (Array.isArray(item.single) && item.single.length > 0) {\n    q = item.single[0];\n  } else if (Array.isArray(item.questions) && item.questions.length === 1) {\n    q = item.questions[0];\n  } else if (item.id || item.question || item.batchId) {\n    // item itself looks like a question\n    q = item;\n  } else {\n    // last resort: try to parse string\n    if (typeof it.json === 'string') {\n      try {\n        const parsed = JSON.parse(it.json);\n        if (Array.isArray(parsed) && parsed.length === 1) {\n          q = parsed[0];\n        }\n      } catch (e) {}\n    }\n    if (!q) q = item;\n  }\n\n  const flat = {};\n\n  // 1) copy simple primitive fields\n  for (const [k, v] of Object.entries(q || {})) {\n    // we'll handle solverA, solverB specially\n    if (k === 'solverA' || k === 'solverB' || k === 'rejectReasons') {\n      continue;\n    }\n\n    // keep only primitives (strings, numbers, booleans, null)\n    if (!isObject(v) && !Array.isArray(v)) {\n      flat[k] = v;\n    }\n    // any other nested objects/arrays are ignored on purpose\n  }\n\n  // 2) flatten solverA -> solverA_* columns\n  if (isObject(q.solverA)) {\n    const sA = q.solverA;\n    flat.solverA_id = sA.id ?? null;\n    flat.solverA_modeledEquation = sA.modeledEquation ?? null;\n    flat.solverA_stepByStepReasoning = sA.stepByStepReasoning ?? null;\n    flat.solverA_finalAnswerOption = sA.finalAnswerOption ?? null;\n    flat.solverA_finalAnswerValue = sA.finalAnswerValue ?? null;\n    flat.solverA_confidence = sA.confidence ?? null;\n    flat.solverA_selectedOption = sA.selectedOption ?? null;\n  }\n\n  // 3) flatten solverB -> solverB_* columns\n  if (isObject(q.solverB)) {\n    const sB = q.solverB;\n    flat.solverB_id = sB.id ?? null;\n    flat.solverB_methodUsed = sB.methodUsed ?? null;\n    flat.solverB_reasoning = sB.reasoning ?? null;\n    flat.solverB_finalAnswerOption = sB.finalAnswerOption ?? null;\n    flat.solverB_finalAnswerValue = sB.finalAnswerValue ?? null;\n    flat.solverB_confidence = sB.confidence ?? null;\n    flat.solverB_selectedOption = sB.selectedOption ?? null;\n  }\n\n  // 4) validatedAt\n  flat.validatedAt = new Date().toISOString();\n\n  // 5) ensure id present\n  if (!flat.id) {\n    flat.id = `q_${Math.random().toString(36).slice(2, 9)}`;\n  }\n\n  out.push({ json: flat });\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        16
      ],
      "id": "58cd1ea4-26e4-4343-ad4f-c08c122c3fea",
      "name": "flatten"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        112,
        176
      ],
      "id": "c1b5a527-7914-4517-ad8c-c9a16e601c6b",
      "name": "Google Gemini Chat Model1",
      "credentials": {
        "googlePalmApi": {
          "id": "jMQZBhyLJqWHQZ0g",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        768,
        -48
      ],
      "id": "0fd7de0b-de6c-4be5-82ae-8750ef38568b",
      "name": "Google Gemini Chat Model2",
      "credentials": {
        "googlePalmApi": {
          "id": "jMQZBhyLJqWHQZ0g",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        768,
        336
      ],
      "id": "d38eda52-4619-416f-ad67-6883ce3b019d",
      "name": "Google Gemini Chat Model3",
      "credentials": {
        "googlePalmApi": {
          "id": "jMQZBhyLJqWHQZ0g",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "YCUmUmNTXdTVrPw4",
          "mode": "list",
          "cachedResultName": "quant_questions",
          "cachedResultUrl": "/projects/n8Ww8ySj97eE00l3/datatables/YCUmUmNTXdTVrPw4"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "isCorrectA": "={{ $json.isCorrectA }}",
            "isCorrectB": "={{ $json.isCorrectB }}",
            "solversAgree": "={{ $json.solversAgree }}",
            "isValidQuestion": "={{ $json.isValidQuestion }}",
            "batchid": "={{ $json.batchId }}",
            "topic": "={{ $json.topic }}",
            "difficulty": "={{ $json.difficulty }}",
            "question": "={{ $json.question }}",
            "optionA": "={{ $json.optionA }}",
            "optionB": "={{ $json.optionB }}",
            "optionC": "={{ $json.optionC }}",
            "optionD": "={{ $json.optionD }}",
            "correctOption": "={{ $json.correctOption }}",
            "solverAOption": "={{ $json.solverAOption }}",
            "solverBOption": "={{ $json.solverBOption }}",
            "solverA_id": "={{ $json.solverA_id }}",
            "solverA_modeledEquation": "={{ $json.solverA_modeledEquation }}",
            "solverA_stepByStepReasoning": "={{ $json.solverA_stepByStepReasoning }}",
            "solverA_finalAnswerOption": "={{ $json.solverA_finalAnswerOption }}",
            "solverA_finalAnswerValue": "={{ $json.solverA_finalAnswerValue }}",
            "solverA_confidence": "={{ $json.solverA_confidence }}",
            "solverA_selectedOption": "={{ $json.solverA_selectedOption }}",
            "solverB_id": "={{ $json.solverB_id }}",
            "solverB_methodUsed": "={{ $json.solverB_methodUsed }}",
            "solverB_reasoning": "={{ $json.solverB_reasoning }}",
            "solverB_finalAnswerOption": "={{ $json.solverB_finalAnswerOption }}",
            "solverB_finalAnswerValue": "={{ $json.solverB_finalAnswerValue }}",
            "solverB_confidence": "={{ $json.solverB_confidence }}",
            "solverB_selectedOption": "={{ $json.solverB_selectedOption }}",
            "validatedAt": "={{ $json.validatedAt }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "batchid",
              "displayName": "batchid",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "topic",
              "displayName": "topic",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "difficulty",
              "displayName": "difficulty",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "question",
              "displayName": "question",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "optionA",
              "displayName": "optionA",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "optionB",
              "displayName": "optionB",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "optionC",
              "displayName": "optionC",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "optionD",
              "displayName": "optionD",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "correctOption",
              "displayName": "correctOption",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverAOption",
              "displayName": "solverAOption",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverBOption",
              "displayName": "solverBOption",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "isCorrectA",
              "displayName": "isCorrectA",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "isCorrectB",
              "displayName": "isCorrectB",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solversAgree",
              "displayName": "solversAgree",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "isValidQuestion",
              "displayName": "isValidQuestion",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "validatedAt",
              "displayName": "validatedAt",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverA_id",
              "displayName": "solverA_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverA_modeledEquation",
              "displayName": "solverA_modeledEquation",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverA_stepByStepReasoning",
              "displayName": "solverA_stepByStepReasoning",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverA_finalAnswerOption",
              "displayName": "solverA_finalAnswerOption",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverA_finalAnswerValue",
              "displayName": "solverA_finalAnswerValue",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverA_confidence",
              "displayName": "solverA_confidence",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverA_selectedOption",
              "displayName": "solverA_selectedOption",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverB_id",
              "displayName": "solverB_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverB_methodUsed",
              "displayName": "solverB_methodUsed",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverB_reasoning",
              "displayName": "solverB_reasoning",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverB_finalAnswerOption",
              "displayName": "solverB_finalAnswerOption",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverB_finalAnswerValue",
              "displayName": "solverB_finalAnswerValue",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverB_confidence",
              "displayName": "solverB_confidence",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "solverB_selectedOption",
              "displayName": "solverB_selectedOption",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        2320,
        -80
      ],
      "id": "1ac3e29b-89c2-4b8e-b8cf-a050d7551932",
      "name": "Insert row"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -256,
        176
      ],
      "id": "241598bb-14b8-4801-92c4-616cd35abd2b",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "jMQZBhyLJqWHQZ0g",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking â€˜Execute workflowâ€™": {
      "main": [
        [
          {
            "node": "Research agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Research agent": {
      "main": [
        [
          {
            "node": "Question Generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Question Generator": {
      "main": [
        [
          {
            "node": "Fan Out Questions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fan Out Questions": {
      "main": [
        [
          {
            "node": "Solver A",
            "type": "main",
            "index": 0
          },
          {
            "node": "Solver B",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merging for correct option",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Orchestrator Node": {
      "main": [
        [
          {
            "node": "Fan OUT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Solver A": {
      "main": [
        [
          {
            "node": "Attach Solver A",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Solver B": {
      "main": [
        [
          {
            "node": "Attach Solver B",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Attach Solver B": {
      "main": [
        [
          {
            "node": "Merging Solvers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Attach Solver A": {
      "main": [
        [
          {
            "node": "Merging Solvers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merging Solvers": {
      "main": [
        [
          {
            "node": "Merging for correct option",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Research agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Question Generator",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Output Parser2": {
      "ai_outputParser": [
        [
          {
            "node": "Solver A",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Output Parser3": {
      "ai_outputParser": [
        [
          {
            "node": "Solver B",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Merging for correct option": {
      "main": [
        [
          {
            "node": "Orchestrator Node",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Valid Question?": {
      "main": [
        [
          {
            "node": "Insert row",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Regeneration Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fan OUT": {
      "main": [
        [
          {
            "node": "flatten",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Regeneration Payload": {
      "main": [
        [
          {
            "node": "Question Generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "flatten": {
      "main": [
        [
          {
            "node": "Is Valid Question?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Question Generator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Solver A",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Solver B",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Insert row": {
      "main": [
        []
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Research agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "9ac8f5d2-cb80-4eba-98ef-19ec5c5faf3e",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "e2d4652cac6a483a9141e3aa7a785ab67a35122e1d6f512de6d4e34911143155"
  },
  "id": "EIZeo2tngEJEO34B",
  "tags": []
}